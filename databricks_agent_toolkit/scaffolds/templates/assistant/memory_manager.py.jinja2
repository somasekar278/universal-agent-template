"""
Memory Manager for L2+ Agents

Handles conversation history persistence using Databricks Lakebase (PostgreSQL).
"""

import json
import os
import string
import random
from typing import Any, Dict, List, Optional

try:
    import psycopg2
    from psycopg2.extras import RealDictCursor
    PSYCOPG2_AVAILABLE = True
except ImportError:
    PSYCOPG2_AVAILABLE = False
    psycopg2 = None
    RealDictCursor = None


class MemoryManager:
    """
    Manages conversation memory using Lakebase (PostgreSQL).
    
    Features:
    - Session-based conversation history
    - Automatic table creation
    - Message limit for context window management
    - System prompt support
    """
    
    def __init__(
        self,
        host: Optional[str] = None,
        database: Optional[str] = None,
        user: Optional[str] = None,
        password: Optional[str] = None,
        port: int = 5432,
        message_limit: int = 20,
    ):
        """
        Initialize Memory Manager.
        
        Args:
            host: Lakebase host (env: LAKEBASE_HOST or PGHOST)
            database: Database name (env: LAKEBASE_DATABASE or PGDATABASE)
            user: Username (env: LAKEBASE_USER or PGUSER)
            password: Password (env: LAKEBASE_PASSWORD or PGPASSWORD)
            port: Port (default: 5432)
            message_limit: Max messages to retrieve (default: 20)
        """
        if not PSYCOPG2_AVAILABLE:
            raise ImportError(
                "psycopg2 is required for memory. "
                "Install with: pip install psycopg2-binary"
            )
        
        # Get connection details from env or arguments
        self.host = host or os.getenv("LAKEBASE_HOST") or os.getenv("PGHOST")
        self.database = database or os.getenv("LAKEBASE_DATABASE") or os.getenv("PGDATABASE")
        self.user = user or os.getenv("LAKEBASE_USER") or os.getenv("PGUSER")
        self.password = password or os.getenv("LAKEBASE_PASSWORD") or os.getenv("PGPASSWORD")
        self.port = port
        self.sslmode = os.getenv("PGSSLMODE", "require")
        self.channel_binding = os.getenv("PGCHANNELBINDING", "prefer")
        self.message_limit = message_limit
        
        # Validate credentials
        if not all([self.host, self.database, self.user, self.password]):
            raise ValueError(
                "Missing Lakebase credentials. Provide via environment variables:\n"
                "LAKEBASE_HOST/PGHOST, LAKEBASE_DATABASE/PGDATABASE, "
                "LAKEBASE_USER/PGUSER, LAKEBASE_PASSWORD/PGPASSWORD"
            )
        
        self.connection = None
        
        # Initialize database
        self._init_database()
    
    def _connect(self):
        """Establish connection to Lakebase."""
        if self.connection is None or self.connection.closed:
            conn_params = {
                "host": self.host,
                "database": self.database,
                "user": self.user,
                "password": self.password,
                "port": self.port,
                "sslmode": self.sslmode,
            }
            
            # Add channel_binding if supported
            if self.channel_binding and self.channel_binding != "prefer":
                try:
                    conn_params["channel_binding"] = self.channel_binding
                except Exception:
                    pass
            
            self.connection = psycopg2.connect(**conn_params)
            print(f"✅ Connected to Lakebase: {self.host}/{self.database} (Username/Password)")
    
    def _init_database(self):
        """Create conversations table if it doesn't exist."""
        self._connect()
        try:
            with self.connection.cursor() as cursor:
                # Check if table exists
                cursor.execute("""
                    SELECT EXISTS (
                        SELECT FROM pg_tables
                        WHERE schemaname = 'public'
                        AND tablename = 'conversations'
                    )
                """)
                exists = cursor.fetchone()[0]
                
                if exists:
                    print("✅ Conversations table already exists")
                else:
                    # Create table
                    cursor.execute("""
                        CREATE TABLE conversations (
                            id SERIAL PRIMARY KEY,
                            session_id VARCHAR(255) NOT NULL,
                            role VARCHAR(50) NOT NULL,
                            content TEXT NOT NULL,
                            timestamp TIMESTAMP DEFAULT NOW(),
                            metadata JSONB
                        )
                    """)
                    
                    # Create indexes
                    cursor.execute("CREATE INDEX idx_session ON conversations(session_id)")
                    cursor.execute("CREATE INDEX idx_timestamp ON conversations(timestamp)")
                    
                    self.connection.commit()
                    print("✅ Created conversations table")
        except Exception as e:
            self.connection.rollback()
            if "permission denied" in str(e).lower():
                print("⚠️  No CREATE permission, assuming table exists")
            else:
                raise
    
    def store_message(
        self,
        session_id: str,
        role: str,
        content: str,
        metadata: Optional[Dict[str, Any]] = None
    ):
        """
        Store a conversation message.
        
        Args:
            session_id: Session identifier
            role: "user", "assistant", or "system"
            content: Message content
            metadata: Optional metadata
        """
        try:
            self._connect()
            with self.connection.cursor() as cursor:
                cursor.execute(
                    """
                    INSERT INTO conversations (session_id, role, content, metadata)
                    VALUES (%s, %s, %s, %s)
                    """,
                    (session_id, role, content, json.dumps(metadata) if metadata else None)
                )
                self.connection.commit()
        except Exception as e:
            self.connection.rollback()
            print(f"⚠️  Could not store message: {e}")
            raise
    
    def get_history(
        self,
        session_id: str,
        include_system: bool = True
    ) -> List[Dict[str, str]]:
        """
        Retrieve conversation history for a session.
        
        Args:
            session_id: Session identifier
            include_system: Whether to include system messages
        
        Returns:
            List of messages in OpenAI format: [{"role": "user", "content": "..."}, ...]
        """
        try:
            self._connect()
            with self.connection.cursor(cursor_factory=RealDictCursor) as cursor:
                query = """
                    SELECT role, content
                    FROM conversations
                    WHERE session_id = %s
                """
                
                if not include_system:
                    query += " AND role != 'system'"
                
                query += " ORDER BY timestamp DESC LIMIT %s"
                
                cursor.execute(query, (session_id, self.message_limit))
                results = cursor.fetchall()
                
                # Reverse to get chronological order
                messages = [{"role": row["role"], "content": row["content"]} for row in reversed(results)]
                return messages
        except Exception as e:
            print(f"⚠️  Could not retrieve history: {e}")
            return []
    
    def clear_history(self, session_id: str):
        """Delete all messages for a session."""
        try:
            self._connect()
            with self.connection.cursor() as cursor:
                cursor.execute("DELETE FROM conversations WHERE session_id = %s", (session_id,))
                self.connection.commit()
            print(f"✅ Cleared history for session: {session_id}")
        except Exception as e:
            self.connection.rollback()
            print(f"⚠️  Could not clear history: {e}")
    
    def close(self):
        """Close database connection."""
        if self.connection and not self.connection.closed:
            self.connection.close()


def generate_session_id() -> str:
    """Generate a unique session ID."""
    chars = string.ascii_lowercase + string.digits
    return "session_" + ''.join(random.choices(chars, k=10))
